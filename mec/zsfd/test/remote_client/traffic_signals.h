/*
 * Generated by the zrpc compiler (rpcc).  DO NOT EDIT!
 * @(#)$Id: traffic_signals.h
 */

#ifndef __CXX_ZRPCC_AUTOGEN_TRAFFIC_SIGNAL_TRAFFIC_SIGNALS_H__
#define __CXX_ZRPCC_AUTOGEN_TRAFFIC_SIGNAL_TRAFFIC_SIGNALS_H__

#ifndef ZIDL_PREFIX
#	ifdef ZIDL_EXPORT
#	define ZIDL_PREFIX __attribute__((visibility("default")))
#	else
#	define ZIDL_PREFIX
#	endif
#endif

#include <stdint.h>
#include "mware/rpc/codegen-helper.h"

using namespace zas::mware::rpc;

// protobuffer version userdef type declaration
namespace traffic_signals_pbf {
	class movement;
	class movement_array;
	class intersection_info;
	class intersection_info_array;
	class gps_info;
	class gps_info_array;
	class vehicle_info;
	class vehicle_info_array;
};

namespace traffic_signals {

const int TRAFFIC_SIGNAL_CTRL_STAT_FIXED_TIME = 16;
const int TRAFFIC_SIGNAL_CTRL_STAT_OFF = 256;
const int TRAFFIC_SIGNAL_CTRL_STAT_SIGNAL_PRIORITY = 8;
const int TRAFFIC_SIGNAL_CTRL_STAT_TRAFFIC_DEPENDENT = 32;
const int TRAFFIC_SIGNAL_CTRL_STAT_FAILURE_FLASH = 4;
const int TRAFFIC_SIGNAL_CTRL_STAT_STOP_TIME = 2;
const int TRAFFIC_SIGNAL_CTRL_STAT_FAILURE_MODE = 128;
const int TRAFFIC_SIGNAL_CTRL_STAT_MANUAL_CTRL = 1;
const int TRAFFIC_SIGNAL_CTRL_STAT_STANDBY = 64;

enum traffic_signal_status
{
	traffic_stat_unknown = 0,
	traffic_stat_green = 1,
	traffic_stat_yellow = 2,
	traffic_stat_red = 3,
	traffic_stat_green_flash = 4,
	traffic_stat_yellow_flash = 5,
	traffic_stat_red_flash = 6,
	traffic_stat_off = 7,
	traffic_stat_other = 8
};
typedef enum_array<traffic_signal_status> traffic_signal_status_array;

enum movement_type
{
	mvt_type_unknown = 0,
	mvt_type_turn_left = 1,
	mvt_type_go_straight = 2,
	mvt_type_turn_right = 3,
	mvt_type_u_turn = 4
};
typedef enum_array<movement_type> movement_type_array;

class ZIDL_PREFIX movement
{
public:
	movement();
	movement(pbf_wrapper wrapper, ::traffic_signals_pbf::movement* pbfmsg);
	movement(const movement& obj) {
		assign(obj);
	}

	void copyfrom(const ::traffic_signals_pbf::movement& obj);
	void copyto(::traffic_signals_pbf::movement& obj) const;

	inline const movement& operator=(const movement& obj) {
		return assign(obj);
	}

	void ___bind(pbf_wrapper wrapper,
		::traffic_signals_pbf::movement* pbfmsg) {
		_pbfobj = pbfmsg;
		_pbf_wrapper = wrapper;
	}

	class ___clazz_type
	{
	public:
		___clazz_type& operator=(movement_type val);
		operator movement_type(void) const;

	private:
		inline movement* ancestor(void) const {
			return _ANCESTOR(movement, type);
		}
	} type;

	class ___clazz_status
	{
	public:
		___clazz_status& operator=(traffic_signal_status val);
		operator traffic_signal_status(void) const;

	private:
		inline movement* ancestor(void) const {
			return _ANCESTOR(movement, status);
		}
	} status;

	class ___clazz_left_time
	{
	public:
		___clazz_left_time& operator=(int32_t val);
		operator int32_t(void) const;

	private:
		inline movement* ancestor(void) const {
			return _ANCESTOR(movement, left_time);
		}
	} left_time;

private:
	const movement& assign(const movement& obj);
	::traffic_signals_pbf::movement* _pbfobj;
	pbf_wrapper _pbf_wrapper;
};

namespace array {

class ZIDL_PREFIX movement
{
public:
	movement(int maxsz = -1);
	~movement();
	const movement& operator=(const movement& val);
	::traffic_signals::movement operator[](int index);

	virtual void clear(void);
	virtual int size(void) const;

protected:
	virtual const traffic_signals_pbf::movement& array_object(int index) const;
	virtual void add(const traffic_signals_pbf::movement& obj);
	virtual traffic_signals_pbf::movement& add(void);
	virtual traffic_signals_pbf::movement& mutable_array_object(int index);

private:
	traffic_signals_pbf::movement_array* _array;
	int _max_size;
};

} // end of namespace array

class ZIDL_PREFIX intersection_info
{
public:
	intersection_info();
	intersection_info(pbf_wrapper wrapper, ::traffic_signals_pbf::intersection_info* pbfmsg);
	intersection_info(const intersection_info& obj) {
		assign(obj);
	}

	void copyfrom(const ::traffic_signals_pbf::intersection_info& obj);
	void copyto(::traffic_signals_pbf::intersection_info& obj) const;

	inline const intersection_info& operator=(const intersection_info& obj) {
		return assign(obj);
	}

	void ___bind(pbf_wrapper wrapper,
		::traffic_signals_pbf::intersection_info* pbfmsg) {
		_pbfobj = pbfmsg;
		_pbf_wrapper = wrapper;
	}

	class ___clazz_approach_id
	{
	public:
		___clazz_approach_id& operator=(std::string val);
		operator std::string(void) const;

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, approach_id);
		}
	} approach_id;

	class ___clazz_timestamp
	{
	public:
		___clazz_timestamp& operator=(int64_t val);
		operator int64_t(void) const;

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, timestamp);
		}
	} timestamp;

	class ___clazz_in_intersection
	{
	public:
		___clazz_in_intersection& operator=(bool val);
		operator bool(void) const;

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, in_intersection);
		}
	} in_intersection;

	class ___clazz_status
	{
	public:
		___clazz_status& operator=(int32_t val);
		operator int32_t(void) const;

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, status);
		}
	} status;

	class ___clazz_movement_count
	{
	public:
		___clazz_movement_count& operator=(int32_t val);
		operator int32_t(void) const;

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, movement_count);
		}
	} movement_count;

	class ___clazz_items : public array::movement
	{
	public:
		const array::movement& operator=(const array::movement& val);
		::traffic_signals::movement operator[](int index);

		int count(void) const { return size(); }
		const ::traffic_signals::movement get(int index) const;
		const ::traffic_signals::movement append(const ::traffic_signals::movement& val);

		void clear(void);
		int size(void) const;

	protected:
		const traffic_signals_pbf::movement& array_object(int index) const;
		void add(const traffic_signals_pbf::movement& obj);
		traffic_signals_pbf::movement& add(void);
		traffic_signals_pbf::movement& mutable_array_object(int index);

	private:
		inline intersection_info* ancestor(void) const {
			return _ANCESTOR(intersection_info, items);
		}
	} items;

private:
	const intersection_info& assign(const intersection_info& obj);
	::traffic_signals_pbf::intersection_info* _pbfobj;
	pbf_wrapper _pbf_wrapper;
};

class ZIDL_PREFIX gps_info
{
public:
	gps_info();
	gps_info(pbf_wrapper wrapper, ::traffic_signals_pbf::gps_info* pbfmsg);
	gps_info(const gps_info& obj) {
		assign(obj);
	}

	void copyfrom(const ::traffic_signals_pbf::gps_info& obj);
	void copyto(::traffic_signals_pbf::gps_info& obj) const;

	inline const gps_info& operator=(const gps_info& obj) {
		return assign(obj);
	}

	void ___bind(pbf_wrapper wrapper,
		::traffic_signals_pbf::gps_info* pbfmsg) {
		_pbfobj = pbfmsg;
		_pbf_wrapper = wrapper;
	}

	class ___clazz_latitude
	{
	public:
		___clazz_latitude& operator=(double val);
		operator double(void) const;

	private:
		inline gps_info* ancestor(void) const {
			return _ANCESTOR(gps_info, latitude);
		}
	} latitude;

	class ___clazz_longitude
	{
	public:
		___clazz_longitude& operator=(double val);
		operator double(void) const;

	private:
		inline gps_info* ancestor(void) const {
			return _ANCESTOR(gps_info, longitude);
		}
	} longitude;

	class ___clazz_direction
	{
	public:
		___clazz_direction& operator=(double val);
		operator double(void) const;

	private:
		inline gps_info* ancestor(void) const {
			return _ANCESTOR(gps_info, direction);
		}
	} direction;

private:
	const gps_info& assign(const gps_info& obj);
	::traffic_signals_pbf::gps_info* _pbfobj;
	pbf_wrapper _pbf_wrapper;
};

class ZIDL_PREFIX vehicle_info
{
public:
	vehicle_info();
	vehicle_info(pbf_wrapper wrapper, ::traffic_signals_pbf::vehicle_info* pbfmsg);
	vehicle_info(const vehicle_info& obj) {
		assign(obj);
	}

	void copyfrom(const ::traffic_signals_pbf::vehicle_info& obj);
	void copyto(::traffic_signals_pbf::vehicle_info& obj) const;

	inline const vehicle_info& operator=(const vehicle_info& obj) {
		return assign(obj);
	}

	void ___bind(pbf_wrapper wrapper,
		::traffic_signals_pbf::vehicle_info* pbfmsg) {
		_pbfobj = pbfmsg;
		_pbf_wrapper = wrapper;
	}

	class ___clazz_veh_id
	{
	public:
		___clazz_veh_id& operator=(std::string val);
		operator std::string(void) const;

	private:
		inline vehicle_info* ancestor(void) const {
			return _ANCESTOR(vehicle_info, veh_id);
		}
	} veh_id;

	class ___clazz_veh_speed
	{
	public:
		___clazz_veh_speed& operator=(double val);
		operator double(void) const;

	private:
		inline vehicle_info* ancestor(void) const {
			return _ANCESTOR(vehicle_info, veh_speed);
		}
	} veh_speed;

	class ___clazz_timestamp
	{
	public:
		___clazz_timestamp& operator=(int64_t val);
		operator int64_t(void) const;

	private:
		inline vehicle_info* ancestor(void) const {
			return _ANCESTOR(vehicle_info, timestamp);
		}
	} timestamp;

	::traffic_signals::gps_info gps;

private:
	const vehicle_info& assign(const vehicle_info& obj);
	::traffic_signals_pbf::vehicle_info* _pbfobj;
	pbf_wrapper _pbf_wrapper;
};

namespace proxy {
class ZIDL_PREFIX vehilce_dt
{
public:
	vehilce_dt()
	: _proxy_base(nullptr) {
	}

	vehilce_dt(const vehilce_dt& obj)
	: _proxy_base(nullptr) {
		if (nullptr == obj._proxy_base) {
			return;
		}
		_proxy_base = obj._proxy_base;
		_proxy_base->addref();
	}

	vehilce_dt(void* instid)
	: _proxy_base(rpcproxy::from_instid(instid,
		&vehilce_dt_static_data_)) {
		assert(nullptr != _proxy_base);
		_proxy_base->addref();
	}

	~vehilce_dt() {
		if (nullptr != _proxy_base) {
			_proxy_base->release();
			_proxy_base = nullptr;
		}
	}

	const vehilce_dt& operator=(const vehilce_dt& obj) {
		if (this == &obj) {
			return *this;
		}
		if (_proxy_base) _proxy_base->release();
		if (obj._proxy_base) obj._proxy_base->addref();
		_proxy_base = obj._proxy_base;
		return *this;
	}

	void* get_instid(void) {
		if (_proxy_base) {
			return _proxy_base->get_instid();
		}
		_proxy_base = rpcproxy::get_instance(nullptr, &vehilce_dt_static_data_);
		return (_proxy_base)
			? _proxy_base->get_instid()
			: nullptr;
	}

public:
	int32_t update_vehicle_info(::traffic_signals::vehicle_info& info);

private:
	rpcproxy*	_proxy_base;
	static const char* vehilce_dt_clsname_;
	static rpcproxy_static_data vehilce_dt_static_data_;
};} // end of namespace proxy

namespace skeleton {
	void import_vehilce_dt(void);
};

class ZIDL_PREFIX vehilce_dt : public skeleton_base
{
public:
	vehilce_dt();
	~vehilce_dt();

	vehilce_dt(const vehilce_dt&) = delete;
	void operator=(const vehilce_dt&) = delete;

	static vehilce_dt* create_instance(void);
	static void destroy_instance(vehilce_dt*);

	public:
	int32_t update_vehicle_info(vehicle_info& info);
};

namespace proxy {

class ZIDL_PREFIX traffic_signal_listener
{
public:
	traffic_signal_listener();
	virtual ~traffic_signal_listener();

public:
	virtual void on_traffic_light_changed(::traffic_signals::intersection_info& int_info);
};} // end of namespace proxy

namespace skeleton {
class ZIDL_PREFIX traffic_signal_listener
{
public:
	traffic_signal_listener();
	traffic_signal_listener(void* inst_id, const char* cliname, const char* inst_name);
	traffic_signal_listener(const traffic_signal_listener&);
	const traffic_signal_listener& operator=(const traffic_signal_listener&);
	~traffic_signal_listener();

public:
	virtual void on_traffic_light_changed(::traffic_signals::intersection_info& int_info);
private:
	void* _inst_id;
	std::string _cliname;
	std::string _inst_name;
};}

namespace proxy {
class ZIDL_PREFIX traffic_signal_info
{
public:
	traffic_signal_info()
	: _proxy_base(nullptr) {
	}

	traffic_signal_info(const traffic_signal_info& obj)
	: _proxy_base(nullptr) {
		if (nullptr == obj._proxy_base) {
			return;
		}
		_proxy_base = obj._proxy_base;
		_proxy_base->addref();
	}

	traffic_signal_info(void* instid)
	: _proxy_base(rpcproxy::from_instid(instid,
		&traffic_signal_info_static_data_)) {
		assert(nullptr != _proxy_base);
		_proxy_base->addref();
	}

	~traffic_signal_info() {
		if (nullptr != _proxy_base) {
			_proxy_base->release();
			_proxy_base = nullptr;
		}
	}

	const traffic_signal_info& operator=(const traffic_signal_info& obj) {
		if (this == &obj) {
			return *this;
		}
		if (_proxy_base) _proxy_base->release();
		if (obj._proxy_base) obj._proxy_base->addref();
		_proxy_base = obj._proxy_base;
		return *this;
	}

	void* get_instid(void) {
		if (_proxy_base) {
			return _proxy_base->get_instid();
		}
		_proxy_base = rpcproxy::get_instance(nullptr, &traffic_signal_info_static_data_);
		return (_proxy_base)
			? _proxy_base->get_instid()
			: nullptr;
	}

public:
	::traffic_signals::intersection_info& get_current();
	int32_t register_traffic_signal_listener(traffic_signal_listener& lnr);
	int32_t deregister_traffic_signal_listener(traffic_signal_listener& lnr);

private:
	rpcproxy*	_proxy_base;
	static const char* traffic_signal_info_clsname_;
	static rpcproxy_static_data traffic_signal_info_static_data_;
};} // end of namespace proxy

namespace skeleton {
	void import_traffic_signal_info(void);
};

class ZIDL_PREFIX traffic_signal_info : public skeleton_base
{
public:
	traffic_signal_info();
	~traffic_signal_info();

	traffic_signal_info(const traffic_signal_info&) = delete;
	void operator=(const traffic_signal_info&) = delete;

	static traffic_signal_info* create_instance(void);
	static void destroy_instance(traffic_signal_info*);

	public:
	intersection_info& get_current();
	int32_t register_traffic_signal_listener(skeleton::traffic_signal_listener& lnr);
	int32_t deregister_traffic_signal_listener(skeleton::traffic_signal_listener& lnr);
};

namespace proxy {
class ZIDL_PREFIX traffic_signal_mgr
{
public:
	traffic_signal_mgr()
	: _proxy_base(nullptr) {
	}

	traffic_signal_mgr(const traffic_signal_mgr& obj)
	: _proxy_base(nullptr) {
		if (nullptr == obj._proxy_base) {
			return;
		}
		_proxy_base = obj._proxy_base;
		_proxy_base->addref();
	}

	traffic_signal_mgr(void* instid)
	: _proxy_base(rpcproxy::from_instid(instid,
		&traffic_signal_mgr_static_data_)) {
		assert(nullptr != _proxy_base);
		_proxy_base->addref();
	}

	~traffic_signal_mgr() {
		if (nullptr != _proxy_base) {
			_proxy_base->release();
			_proxy_base = nullptr;
		}
	}

	const traffic_signal_mgr& operator=(const traffic_signal_mgr& obj) {
		if (this == &obj) {
			return *this;
		}
		if (_proxy_base) _proxy_base->release();
		if (obj._proxy_base) obj._proxy_base->addref();
		_proxy_base = obj._proxy_base;
		return *this;
	}

	void* get_instid(void) {
		if (_proxy_base) {
			return _proxy_base->get_instid();
		}
		_proxy_base = rpcproxy::get_instance(nullptr, &traffic_signal_mgr_static_data_);
		return (_proxy_base)
			? _proxy_base->get_instid()
			: nullptr;
	}

public:
	static traffic_signal_mgr& inst(void);
	vehilce_dt& register_vehicle(::traffic_signals::vehicle_info& info);
	traffic_signal_info& get_traffic_signal(::traffic_signals::vehicle_info& info);

private:
	rpcproxy*	_proxy_base;
	static const char* traffic_signal_mgr_clsname_;
	static rpcproxy_static_data traffic_signal_mgr_static_data_;
};} // end of namespace proxy

namespace skeleton {
	void import_traffic_signal_mgr(void);
};

class ZIDL_PREFIX traffic_signal_mgr : public skeleton_base
{
public:
	traffic_signal_mgr();
	~traffic_signal_mgr();

	traffic_signal_mgr(const traffic_signal_mgr&) = delete;
	void operator=(const traffic_signal_mgr&) = delete;

	static traffic_signal_mgr* create_instance(void);
	static void destroy_instance(traffic_signal_mgr*);

	public:
	vehilce_dt& register_vehicle(vehicle_info& info);
	traffic_signal_info& get_traffic_signal(vehicle_info& info);
};

}// end of namespace traffic_signals
#endif /* __CXX_ZRPCC_AUTOGEN_TRAFFIC_SIGNAL_TRAFFIC_SIGNALS_H__ */
/* EOF */