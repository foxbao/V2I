/*
 * Generated by the zrpc compiler (rpcc).  DO NOT EDIT!
 * @(#)$Id: traffic_signals-structs.cpp
 */

#include "mware/rpc/rpcerror.h"
#include "common/traffic_signals-internal.h"

namespace traffic_signals {

movement::movement()
: _pbfobj(NULL)
{
	_pbf_wrapper = new struct_wrapper::___movement_wrapper();
	assert(_pbf_wrapper.get());
	_pbfobj = reinterpret_cast<traffic_signals_pbf::movement*>
		(_pbf_wrapper->get_pbfmessage());
	assert(_pbfobj);
}

movement::movement(pbf_wrapper wrapper, ::traffic_signals_pbf::movement* pbfmsg)
: _pbf_wrapper(wrapper), _pbfobj(pbfmsg)
{
	assert(nullptr != pbfmsg);
}

const movement& movement::assign(const movement& obj)
{
	if (this == &obj || _pbfobj == obj._pbfobj) {
		return *this;
	}
	*_pbfobj = *obj._pbfobj;
	return *this;
}

void movement::copyfrom(const ::traffic_signals_pbf::movement& obj)
{
	if (&obj == _pbfobj) return;
	*_pbfobj = obj;
}

void movement::copyto(::traffic_signals_pbf::movement& obj) const
{
	if (&obj == _pbfobj) return;
	obj = *_pbfobj;
}

movement::___clazz_type& movement::___clazz_type::operator=(movement_type val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_type((int32_t)val);
	return *this;
}

movement::___clazz_type::operator movement_type(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return (movement_type)pobj->type();
}

movement::___clazz_status& movement::___clazz_status::operator=(traffic_signal_status val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_status((int32_t)val);
	return *this;
}

movement::___clazz_status::operator traffic_signal_status(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return (traffic_signal_status)pobj->status();
}

movement::___clazz_left_time& movement::___clazz_left_time::operator=(int32_t val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_left_time(val);
	return *this;
}

movement::___clazz_left_time::operator int32_t(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->left_time();
}

namespace array {

movement::movement(int maxsz)
: _array(new traffic_signals_pbf::movement_array())
, _max_size(maxsz) {
	assert(nullptr != _array);
}

movement::~movement()
{
	if (nullptr != _array) {
		delete _array;
		_array = nullptr;
	}
}

const movement& movement::operator=(
	const movement& val)
{
	if (this == &val) {
		return *this;
	}
	int sz = val.size();
	if (_max_size > 0 && sz > _max_size) {
		sz = _max_size;
	}
	// copy the array
	clear();
	for (int i = 0; i < sz; ++i) {
		add(val.array_object(i));
	}
	return *this;
}

::traffic_signals::movement movement::operator[](int index)
{
	if (_max_size > 0 && index >= _max_size) {
		throw_rpc_error_array_exceed_boundary();
	}
	if (index >= size()) {
		throw_rpc_error_array_exceed_boundary();
	}
	return ::traffic_signals::movement(
		zas::mware::rpc::pbf_wrapper(nullptr),
		&mutable_array_object(index));
}

void movement::clear(void)
{
	if (_array) {
		_array->clear_array();
	}
}

int movement::size(void) const
{
	if (!_array) {
		return 0;
	}
	int ret = _array->array_size();
	if (_max_size > 0 && _max_size < ret) {
		ret = _max_size;
	}
	return ret;
}

const traffic_signals_pbf::movement& movement::array_object(int index) const
{
	if (index < 0 || index >= size()) {
		throw_rpc_error_array_exceed_boundary();
	}
	assert(nullptr != _array);
	return _array->array(index);
}

void movement::add(const traffic_signals_pbf::movement& obj)
{
	assert(nullptr != _array);
	if (_max_size > 0 && size() >= _max_size) {
		throw_rpc_error_array_exceed_boundary();
	}
	auto* new_obj = _array->add_array();
	*new_obj = obj;
}

traffic_signals_pbf::movement& movement::add(void)
{
	assert(nullptr != _array);
	if (_max_size > 0 && size() >= _max_size) {
		throw_rpc_error_array_exceed_boundary();
	}
	return *_array->add_array();
}

traffic_signals_pbf::movement& movement::mutable_array_object(int index)
{
	if (index < 0 || index >= size()) {
		throw_rpc_error_array_exceed_boundary();
	}
	assert(nullptr != _array);
	return *_array->mutable_array(index);
}

} // end of namespace array

intersection_info::intersection_info()
: _pbfobj(NULL)
{
	_pbf_wrapper = new struct_wrapper::___intersection_info_wrapper();
	assert(_pbf_wrapper.get());
	_pbfobj = reinterpret_cast<traffic_signals_pbf::intersection_info*>
		(_pbf_wrapper->get_pbfmessage());
	assert(_pbfobj);
}

intersection_info::intersection_info(pbf_wrapper wrapper, ::traffic_signals_pbf::intersection_info* pbfmsg)
: _pbf_wrapper(wrapper), _pbfobj(pbfmsg)
{
	assert(nullptr != pbfmsg);
}

const intersection_info& intersection_info::assign(const intersection_info& obj)
{
	if (this == &obj || _pbfobj == obj._pbfobj) {
		return *this;
	}
	*_pbfobj = *obj._pbfobj;
	return *this;
}

void intersection_info::copyfrom(const ::traffic_signals_pbf::intersection_info& obj)
{
	if (&obj == _pbfobj) return;
	*_pbfobj = obj;
}

void intersection_info::copyto(::traffic_signals_pbf::intersection_info& obj) const
{
	if (&obj == _pbfobj) return;
	obj = *_pbfobj;
}

intersection_info::___clazz_approach_id& intersection_info::___clazz_approach_id::operator=(std::string val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_approach_id(val);
	return *this;
}

intersection_info::___clazz_approach_id::operator std::string(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->approach_id();
}

intersection_info::___clazz_timestamp& intersection_info::___clazz_timestamp::operator=(int64_t val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_timestamp(val);
	return *this;
}

intersection_info::___clazz_timestamp::operator int64_t(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->timestamp();
}

intersection_info::___clazz_in_intersection& intersection_info::___clazz_in_intersection::operator=(bool val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_in_intersection(val);
	return *this;
}

intersection_info::___clazz_in_intersection::operator bool(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->in_intersection();
}

intersection_info::___clazz_status& intersection_info::___clazz_status::operator=(int32_t val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_status(val);
	return *this;
}

intersection_info::___clazz_status::operator int32_t(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->status();
}

intersection_info::___clazz_movement_count& intersection_info::___clazz_movement_count::operator=(int32_t val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_movement_count(val);
	return *this;
}

intersection_info::___clazz_movement_count::operator int32_t(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->movement_count();
}

const array::movement&
intersection_info::___clazz_items::operator=(
	const array::movement& val)
{
	return array::movement::operator=(val);
}

::traffic_signals::movement
intersection_info::___clazz_items::operator[](int index)
{
	if (index >= 10) {
		throw_rpc_error_array_exceed_boundary();
	}
	if (index < 0 || index >= size()) {
		throw_rpc_error_array_exceed_boundary();
	}
	return ::traffic_signals::movement(
		ancestor()->_pbf_wrapper, 
		&mutable_array_object(index));
}

const ::traffic_signals::movement
intersection_info::___clazz_items::get(int index) const
{
	if (index >= 10) {
		throw_rpc_error_array_exceed_boundary();
	}
	if (index < 0 || index >= size()) {
		throw_rpc_error_array_exceed_boundary();
	}
	traffic_signals_pbf::movement* item = const_cast<
		traffic_signals_pbf::movement*>(&array_object(index));
	return ::traffic_signals::movement(
		ancestor()->_pbf_wrapper, item);
}

const ::traffic_signals::movement
intersection_info::___clazz_items::append(const ::traffic_signals::movement& val)
{
	if (size() >= 10) {
		throw_rpc_error_array_exceed_boundary();
	}
	auto& item = add();
	val.copyto(item);
	return ::traffic_signals::movement(ancestor()->_pbf_wrapper, &item);
}

void intersection_info::___clazz_items::clear(void)
{
	auto* p = ancestor()->_pbfobj;
	p->clear_items();
}

int intersection_info::___clazz_items::size(void) const
{
	auto* p = ancestor()->_pbfobj;
	return p->items_size();
}

const traffic_signals_pbf::movement&
intersection_info::___clazz_items::array_object(int index) const
{
	auto* p = ancestor()->_pbfobj;
	return p->items(index);
}

void intersection_info::___clazz_items::add(const traffic_signals_pbf::movement& obj)
{
	auto* p = ancestor()->_pbfobj;
	auto* new_obj = p->add_items();
	*new_obj = obj;
}

traffic_signals_pbf::movement& intersection_info::___clazz_items::add(void)
{
	auto* p = ancestor()->_pbfobj;
	return *p->add_items();
}

traffic_signals_pbf::movement&
intersection_info::___clazz_items::mutable_array_object(int index)
{
	auto* p = ancestor()->_pbfobj;
	return *p->mutable_items(index);
}

gps_info::gps_info()
: _pbfobj(NULL)
{
	_pbf_wrapper = new struct_wrapper::___gps_info_wrapper();
	assert(_pbf_wrapper.get());
	_pbfobj = reinterpret_cast<traffic_signals_pbf::gps_info*>
		(_pbf_wrapper->get_pbfmessage());
	assert(_pbfobj);
}

gps_info::gps_info(pbf_wrapper wrapper, ::traffic_signals_pbf::gps_info* pbfmsg)
: _pbf_wrapper(wrapper), _pbfobj(pbfmsg)
{
	assert(nullptr != pbfmsg);
}

const gps_info& gps_info::assign(const gps_info& obj)
{
	if (this == &obj || _pbfobj == obj._pbfobj) {
		return *this;
	}
	*_pbfobj = *obj._pbfobj;
	return *this;
}

void gps_info::copyfrom(const ::traffic_signals_pbf::gps_info& obj)
{
	if (&obj == _pbfobj) return;
	*_pbfobj = obj;
}

void gps_info::copyto(::traffic_signals_pbf::gps_info& obj) const
{
	if (&obj == _pbfobj) return;
	obj = *_pbfobj;
}

gps_info::___clazz_latitude& gps_info::___clazz_latitude::operator=(double val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_latitude(val);
	return *this;
}

gps_info::___clazz_latitude::operator double(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->latitude();
}

gps_info::___clazz_longitude& gps_info::___clazz_longitude::operator=(double val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_longitude(val);
	return *this;
}

gps_info::___clazz_longitude::operator double(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->longitude();
}

gps_info::___clazz_direction& gps_info::___clazz_direction::operator=(double val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_direction(val);
	return *this;
}

gps_info::___clazz_direction::operator double(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->direction();
}

vehicle_info::vehicle_info()
: _pbfobj(NULL)
{
	_pbf_wrapper = new struct_wrapper::___vehicle_info_wrapper();
	assert(_pbf_wrapper.get());
	_pbfobj = reinterpret_cast<traffic_signals_pbf::vehicle_info*>
		(_pbf_wrapper->get_pbfmessage());
	assert(_pbfobj);
	gps.___bind(_pbf_wrapper, _pbfobj->mutable_gps());
}

vehicle_info::vehicle_info(pbf_wrapper wrapper, ::traffic_signals_pbf::vehicle_info* pbfmsg)
: _pbf_wrapper(wrapper), _pbfobj(pbfmsg)
, gps(wrapper, pbfmsg->mutable_gps())
{
	assert(nullptr != pbfmsg);
}

const vehicle_info& vehicle_info::assign(const vehicle_info& obj)
{
	if (this == &obj || _pbfobj == obj._pbfobj) {
		return *this;
	}
	*_pbfobj = *obj._pbfobj;
	return *this;
}

void vehicle_info::copyfrom(const ::traffic_signals_pbf::vehicle_info& obj)
{
	if (&obj == _pbfobj) return;
	*_pbfobj = obj;
}

void vehicle_info::copyto(::traffic_signals_pbf::vehicle_info& obj) const
{
	if (&obj == _pbfobj) return;
	obj = *_pbfobj;
}

vehicle_info::___clazz_veh_id& vehicle_info::___clazz_veh_id::operator=(std::string val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_veh_id(val);
	return *this;
}

vehicle_info::___clazz_veh_id::operator std::string(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->veh_id();
}

vehicle_info::___clazz_veh_speed& vehicle_info::___clazz_veh_speed::operator=(double val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_veh_speed(val);
	return *this;
}

vehicle_info::___clazz_veh_speed::operator double(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->veh_speed();
}

vehicle_info::___clazz_timestamp& vehicle_info::___clazz_timestamp::operator=(int64_t val)
{
	auto* pobj = ancestor()->_pbfobj;
	pobj->set_timestamp(val);
	return *this;
}

vehicle_info::___clazz_timestamp::operator int64_t(void) const
{
	auto* pobj = ancestor()->_pbfobj;
	return pobj->timestamp();
}

} // end of namespace traffic_signals